import { IndexedClause, SubsumptionIndex } from './subsumption';
import { SymbolTable } from './ast';
import { getResolutions, applyResolution } from './resolution';

/**
 * Priority queue implementation for clause selection
 */
export class PriorityQueue<T> {
  private heap: Array<{ item: T; priority: number }> = [];

  /**
   * Comparison function follows the same convention as Array.sort().
   */
  constructor(private compareFn: (a: number, b: number) => number) {}

  /**
   * Insert an item with given priority.
   */
  insert(item: T, priority: number): void {
    this.heap.push({ item, priority });
    this.bubbleUp(this.heap.length - 1);
  }

  /**
   * Extract the item with minimum priority.
   */
  pop(): T | null {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop()!.item;

    const min = this.heap[0];
    this.heap[0] = this.heap.pop()!;
    this.bubbleDown(0);
    return min.item;
  }

  /**
   * Check if queue is empty.
   */
  isEmpty(): boolean {
    return this.heap.length === 0;
  }

  /**
   * Get number of items in queue.
   */
  size(): number {
    return this.heap.length;
  }

  /**
   * Remove a specific item from the queue.
   */
  remove(predicate: (item: T) => boolean): boolean {
    const index = this.heap.findIndex((entry) => predicate(entry.item));
    if (index === -1) return false;

    if (index === this.heap.length - 1) {
      this.heap.pop();
    } else {
      this.heap[index] = this.heap.pop()!;

      // One will be a no-op:
      this.bubbleUp(index);
      this.bubbleDown(index);
    }
    return true;
  }

  private bubbleUp(index: number): void {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (
        this.compareFn(
          this.heap[index].priority,
          this.heap[parentIndex].priority
        ) >= 0
      ) {
        break;
      }
      [this.heap[index], this.heap[parentIndex]] = [
        this.heap[parentIndex],
        this.heap[index],
      ];
      index = parentIndex;
    }
  }

  private bubbleDown(index: number): void {
    while (true) {
      let minIndex = index;
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;

      if (
        leftChild < this.heap.length &&
        this.compareFn(
          this.heap[leftChild].priority,
          this.heap[minIndex].priority
        ) < 0
      ) {
        minIndex = leftChild;
      }

      if (
        rightChild < this.heap.length &&
        this.compareFn(
          this.heap[rightChild].priority,
          this.heap[minIndex].priority
        ) < 0
      ) {
        minIndex = rightChild;
      }

      if (minIndex === index) break;

      [this.heap[index], this.heap[minIndex]] = [
        this.heap[minIndex],
        this.heap[index],
      ];
      index = minIndex;
    }
  }
}

/**
 * Manages active and passive clause sets with two priority queues. Most of the
 * time we take from the heuristic queue which orders clauses based on size and
 * other heuristics (mainly to keep active clauses small, NP-completeness is a
 * bitch).
 */
export class ClauseSet {
  /**
   * Active clauses have already been selected. Resolutions are only every
   * generated between the selected clause and the other active clauses, to
   * keep the search space bounded:
   */
  private active: Set<IndexedClause> = new Set();

  /**
   * List of clauses that have been generated by resolutions or from axiom
   * schemas during inference. They are pushed into the active set one at a
   * time during search:
   */
  private passive: {
    ageQueue: PriorityQueue<IndexedClause>;
    heuristicQueue: PriorityQueue<IndexedClause>;
  };

  /**
   * One clause is taken from the age-based queue for every `ratio` clauses
   * taken from the heuristic queue. This is to ensure completeness - every
   * clause _eventually_ gets selected, regardless of how poorly it matches
   * our set of heuristics:
   */
  private readonly ratio: number = 4;
  private counter: number = 0;

  /**
   * We use subsumption as a cheaper proxy for implication to prune clauses
   * that are redundant, i.e. already implied by another clause in the set:
   */
  private subsumptionIndex: SubsumptionIndex;

  constructor(symbolTable: SymbolTable) {
    this.subsumptionIndex = new SubsumptionIndex(symbolTable);

    this.passive = {
      ageQueue: new PriorityQueue<IndexedClause>((a, b) => a - b),
      heuristicQueue: new PriorityQueue<IndexedClause>((a, b) => a - b),
    };
  }

  /**
   * Selects the next clause from one of the queues. Note that we do soft
   * deletion of clauses from the queues by marking them as 'noLongerPassive: true',
   * so we may have to pop the queue multiple times before we get a hit.
   */
  selectClause(): IndexedClause | null {
    let queue: PriorityQueue<IndexedClause>;
    if (this.counter % (this.ratio + 1) === 0) {
      queue = this.passive.ageQueue;
    } else {
      queue = this.passive.heuristicQueue;
    }

    let clause = this.extract(queue);
    if (!clause) {
      const otherQueue =
        queue === this.passive.ageQueue
          ? this.passive.heuristicQueue
          : this.passive.ageQueue;
      clause = this.extract(otherQueue);
    }

    if (clause) {
      this.counter++;
    }

    return clause;
  }

  private extract(queue: PriorityQueue<IndexedClause>): IndexedClause | null {
    while (!queue.isEmpty()) {
      const clause = queue.pop();
      if (clause && !clause.noLongerPassive) {
        return clause;
      }
    }
    return null;
  }

  insert(clause: IndexedClause): void {
    const indexed = this.subsumptionIndex.insert(clause);
    this.passive.ageQueue.insert(indexed, indexed.age);
    this.passive.heuristicQueue.insert(indexed, indexed.atoms.length);
  }

  activate(clause: IndexedClause): void {
    clause.noLongerPassive = true; // soft-delete from queues
    this.active.add(clause);
  }

  remove(clause: IndexedClause): void {
    this.active.delete(clause);
    clause.noLongerPassive = true;
    this.subsumptionIndex.remove(clause);
  }

  /**
   * Generate all resolvents between the given clause and the active set.
   */
  generateResolvents(clause: IndexedClause): IndexedClause[] {
    const resolvents: IndexedClause[] = [];

    for (const activeClause of this.active) {
      if (activeClause.id === clause.id) continue;

      // TODO: add factoring/simplification/tautology detection too

      const resolutions = getResolutions(clause, activeClause);
      for (const resolution of resolutions) {
        const resolvent = applyResolution(resolution);
        const indexed = this.subsumptionIndex.insert(resolvent);
        resolvents.push(indexed);
      }
    }

    return resolvents;
  }

  getSubsumptionIndex(): SubsumptionIndex {
    return this.subsumptionIndex;
  }

  /**
   * Get all active clauses (for forward subsumption check)
   */
  getActive(): Set<IndexedClause> {
    return this.active;
  }

  /**
   * Check if there are passive clauses available - approximate, may include
   * undeleted active clauses as well.
   */
  hasPassiveClauses(): boolean {
    return (
      !this.passive.ageQueue.isEmpty() || !this.passive.heuristicQueue.isEmpty()
    );
  }

  /**
   * Get total number of clauses (active and passive).
   */
  size(): number {
    return this.subsumptionIndex.size();
  }

  /**
   * Get number of active clauses.
   */
  activeSize(): number {
    return this.active.size;
  }

  /**
   * Get number of passive clauses (approximate, may include soft-deleted
   * active clauses as well).
   */
  passiveSize(): number {
    return Math.max(
      this.passive.ageQueue.size(),
      this.passive.heuristicQueue.size()
    );
  }
}
